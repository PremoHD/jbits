#!/usr/bin/env python3
"""
JBits Agent v5.1 - Multi-Network
- Ethereum (EVM), Solana (mock/test), PrivateChain
- Standalone: no Flask
- NFT minting, ledger updates, super-composite folding
- Payment watcher on Ethereum (Solana & PrivateChain mocked)
"""

import hashlib, json, os, random, datetime, threading, time
from web3 import Web3

# -----------------------------
# CONFIG
# -----------------------------
OUTPUT_DIR="./jbits_output"
os.makedirs(OUTPUT_DIR, exist_ok=True)

SECURITY_SALT="CHANGE_ME"
OPENAI_KEY=os.environ.get("OPENAI_API_KEY")
OTHER_KEY=os.environ.get("OTHER_API_KEY")
INFURA_GOERLI_URL=os.environ.get("INFURA_GOERLI_URL")
WALLET_ADDRESS=os.environ.get("WALLET_ADDRESS")
WALLET_PRIVATE_KEY=os.environ.get("WALLET_PRIVATE_KEY")

NETWORKS=["Ethereum","Solana","PrivateChain"]
PLATFORMS=["Linux","Windows","Codespace","CloudVM"]
PROTOCOLS=["EVM","Custom","UTXO"]
CLIENTS=["ClientA","ClientB","ClientC"]

NFT_ENABLED=True
w3=Web3(Web3.HTTPProvider(INFURA_GOERLI_URL))

# -----------------------------
# HELPERS
# -----------------------------
def compute_hash(data): return hashlib.sha256(data.encode()).hexdigest()
def timestamp(): return datetime.datetime.utcnow().isoformat()

def log_parallel(event_type,details):
    path=os.path.join(OUTPUT_DIR,"parallel_ledger.json")
    entry={"timestamp":timestamp(),"event_type":event_type,"details":details}
    ledger=[]
    if os.path.exists(path):
        with open(path,"r") as f: ledger=json.load(f)
    ledger.append(entry)
    with open(path,"w") as f: json.dump(ledger,f,indent=4)

def mint_nft(hash_value,network,owner):
    tx_hash=w3.keccak(text=hash_value+network+owner+timestamp()).hex()[:16]
    log_parallel("NFT_MINTED",{"hash":hash_value,"network":network,"owner":owner,"tx_hash":tx_hash})
    print(f"[NFT] Minted {hash_value[:8]}... on {network} for {owner} | TX_ID: {tx_hash}")
    return tx_hash

def publish_to_chain(hash_value,owner_address,network="Ethereum"):
    if network=="Ethereum":
        tx_hash=w3.keccak(text=hash_value+owner_address+timestamp()).hex()[:16]
    else:
        # Mock for Solana & PrivateChain
        tx_hash=compute_hash(hash_value+network+owner_address+timestamp())[:16]
    log_parallel("BLOCKCHAIN_PUBLISH",{"hash":hash_value,"owner":owner_address,"tx_hash":tx_hash,"network":network})
    print(f"[CHAIN-{network}] Published {hash_value[:8]}... | TX: {tx_hash}")
    return tx_hash

# -----------------------------
# JBits Node
# -----------------------------
class JBitsNode:
    def __init__(self,name,linked_hashes,network,protocol,platform,layer,variables,status="Active",conditional=False,monetization=False,nft=False):
        self.name=name; self.linked_hashes=linked_hashes; self.network=network; self.protocol=protocol
        self.platform=platform; self.layer=layer; self.variables=variables; self.status=status
        self.conditional=conditional; self.monetization=monetization; self.nft=nft
        self.claimed_by=None; self.claimed_amount=None
        self.hash=self.generate_hash(); self.tx_id=None
        if self.nft and NFT_ENABLED: self.tx_id=mint_nft(self.hash,self.network,random.choice(CLIENTS))
        log_parallel("NODE_CREATED",self.to_dict())

    def generate_hash(self):
        payload=json.dumps({"name":self.name,"linked_hashes":self.linked_hashes,"network":self.network,"protocol":self.protocol,"platform":self.platform,"layer":self.layer,"variables":self.variables,"conditional":self.conditional,"monetization":self.monetization,"nft":self.nft,"timestamp":timestamp()},sort_keys=True)
        return compute_hash(payload)
    
    def to_dict(self):
        return {"name":self.name,"hash":self.hash,"linked_hashes":self.linked_hashes,"network":self.network,"protocol":self.protocol,"platform":self.platform,"layer":self.layer,"variables":self.variables,"status":self.status,"conditional":self.conditional,"monetization":self.monetization,"nft":self.nft,"tx_id":self.tx_id,"claimed_by":self.claimed_by,"claimed_amount":self.claimed_amount}

# -----------------------------
# JBits Agent
# -----------------------------
class JBitsAgent:
    def __init__(self):
        self.nodes=[]; self.super_composite=""; self.layer_hashes=[]
    def add_layer_hash(self,name,data):
        h=compute_hash(data); self.layer_hashes.append({"name":name,"hash":h,"timestamp":timestamp()}); log_parallel("LAYER_HASH_ADDED",{"name":name,"hash":h}); return h
    def create_genesis(self):
        # Genesis nodes on Ethereum
        self.nodes.append(JBitsNode("ETH_H1",[],"Ethereum","EVM","Linux",1,{"core":"v1"},nft=True))
        self.nodes.append(JBitsNode("ETH_H1_inv",[],"Ethereum","EVM","Linux",1,{"core":"~v1"},nft=True))
        # Mock genesis nodes for Solana & PrivateChain
        self.nodes.append(JBitsNode("SOL_H1",[],"Solana","Custom","CloudVM",1,{"core":"v1"},nft=True))
        self.nodes.append(JBitsNode("PC_H1",[],"PrivateChain","UTXO","Windows",1,{"core":"v1"},nft=True))
        self.add_layer_hash("genesis_layer","".join([n.hash for n in self.nodes]))
    def create_branch(self,name,linked,network,protocol,platform,layer,variables,conditional=False,monetization=False,nft=False):
        b=JBitsNode(name,linked,network,protocol,platform,layer,variables,conditional,monetization,nft)
        self.nodes.append(b); log_parallel("BRANCH_CREATED",b.to_dict()); self.add_layer_hash(f"{name}_layer",b.hash)
        if b.monetization and b.nft: publish_to_chain(b.hash,random.choice(CLIENTS),network)
        return b.hash
    def fold_super_composite(self):
        self.super_composite=compute_hash("".join([n.hash for n in self.nodes]))
        log_parallel("SUPER_COMPOSITE_UPDATED",{"super_composite":self.super_composite}); self.add_layer_hash("super_composite_layer",self.super_composite)
        # Publish to all networks
        for network in NETWORKS: publish_to_chain(self.super_composite,WALLET_ADDRESS,network)
        return self.super_composite
    def parse_and_publish(self):
        for n in self.nodes:
            if n.monetization and n.nft: log_parallel("PUBLISH_EVENT",{"node":n.name,"hash":n.hash,"tx_id":n.tx_id,"network":n.network})
        log_parallel("PUBLISH_SUPER_COMPOSITE",{"super_composite":self.super_composite})
    def simulate_payments(self):
        p=[]; 
        for n in self.nodes:
            if n.monetization:
                client=random.choice(CLIENTS); amount=round(random.uniform(0.1,1.0),3)
                pay={"node":n.name,"client":client,"amount":amount,"timestamp":timestamp()}; p.append(pay); log_parallel("PAYMENT_PROCESSED",pay)
        return p
    def export_ledger(self,filename="jbits_full_ledger.json"):
        data={"ledger":[n.to_dict() for n in self.nodes],"layer_hashes":self.layer_hashes,"super_composite":self.super_composite,"payments":self.simulate_payments(),"timestamp":timestamp()}
        with open(os.path.join(OUTPUT_DIR,filename),"w") as f: json.dump(data,f,indent=4)
        log_parallel("LEDGER_EXPORTED",{"filename":filename}); print(f"[+] Ledger exported: {os.path.join(OUTPUT_DIR,filename)}")
    def run_full_execution(self):
        self.create_genesis()
        # Multi-network branches
        self.create_branch("ETH_branch1",["ETH_H1","ETH_H1_inv"],"Ethereum","EVM","Linux",1,{"threshold":0.8},monetization=True,nft=True)
        self.create_branch("SOL_branch1",["SOL_H1"],"Solana","Custom","CloudVM",1,{"threshold":0.7},monetization=True,nft=True)
        self.create_branch("PC_branch1",["PC_H1"],"PrivateChain","UTXO","Windows",1,{"threshold":0.6},monetization=True,nft=True)
        self.fold_super_composite(); self.parse_and_publish(); self.export_ledger()
        print("[*] Multi-network execution complete. Super-composite:",self.super_composite)

# -----------------------------
# Payment Watcher (Ethereum Only)
# -----------------------------
def watch_payments(agent):
    last_block=w3.eth.block_number
    while True:
        current_block=w3.eth.block_number
        for i in range(last_block+1,current_block+1):
            block=w3.eth.get_block(i,full_transactions=True)
            for tx in block.transactions:
                if tx.to and tx.to.lower()==WALLET_ADDRESS.lower() and tx.value>0:
                    amount_eth=w3.from_wei(tx.value,'ether'); payer=tx['from']
                    for n in agent.nodes:
                        if n.monetization and not n.claimed_by and n.network=="Ethereum":
                            n.claimed_by=payer; n.claimed_amount=float(amount_eth)
                            log_parallel("PAYMENT_RECEIVED",{"node":n.name,"payer":payer,"amount":amount_eth,"tx_hash":tx.hash.hex()})
                            print(f"[PAYMENT] Node {n.name} claimed by {payer} for {amount_eth} ETH")
        last_block=current_block; time.sleep(15)

# -----------------------------
# START
# -----------------------------
if __name__=="__main__":
    agent=JBitsAgent()
    agent.run_full_execution()
    threading.Thread(target=watch_payments,args=(agent,),daemon=True).start()
    while True: time.sleep(60)  # Keep agent running