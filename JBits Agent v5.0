#!/usr/bin/env python3
"""
Ultimate JBits Agent v5.0 - Single Copy-Paste Version
- Autonomous JBits network
- NFT minting & blockchain/testnet publishing
- ETH payment detection & auto-claiming
- Full ledger: main, parallel, billing
- Layer hashes, negative/inverted branches
- API tracking & parsing
"""

import hashlib, json, os, random, datetime, threading, time
from flask import Flask, request, jsonify
from web3 import Web3

# -----------------------------
# CONFIG
# -----------------------------
OUTPUT_DIR="./jbits_output"
os.makedirs(OUTPUT_DIR, exist_ok=True)

SECURITY_SALT="CHANGE_ME"
OPENAI_KEY=os.environ.get("OPENAI_API_KEY")
OTHER_KEY=os.environ.get("OTHER_API_KEY")
INFURA_GOERLI_URL=os.environ.get("INFURA_GOERLI_URL")
WALLET_ADDRESS=os.environ.get("WALLET_ADDRESS")
WALLET_PRIVATE_KEY=os.environ.get("WALLET_PRIVATE_KEY")

API_KEYS={"free":{"limit":100,"rate_per_min":10},"pro":{"limit":10000,"rate_per_min":120},"enterprise":{"limit":1000000,"rate_per_min":1000}}
API_KEY_STORE={}

NETWORKS=["Ethereum","Solana","PrivateChain","OffChain"]
PLATFORMS=["Linux","Windows","Codespace","CloudVM"]
PROTOCOLS=["EVM","UTXO","Custom","REST"]
CLIENTS=["ClientA","ClientB","ClientC"]

NFT_ENABLED=True
w3=Web3(Web3.HTTPProvider(INFURA_GOERLI_URL))

# -----------------------------
# HELPERS
# -----------------------------
def compute_hash(data): return hashlib.sha256(data.encode()).hexdigest()
def timestamp(): return datetime.datetime.utcnow().isoformat()
def hash_ip(ip): return compute_hash(ip + SECURITY_SALT)
def hash_api_key(key): return compute_hash(key + SECURITY_SALT)
def api_key_fingerprint(key): return key[:4]+"****"

def log_parallel(event_type,details):
    path=os.path.join(OUTPUT_DIR,"parallel_ledger.json")
    entry={"timestamp":timestamp(),"event_type":event_type,"details":details}
    ledger=[]
    if os.path.exists(path):
        with open(path,"r") as f: ledger=json.load(f)
    ledger.append(entry)
    with open(path,"w") as f: json.dump(ledger,f,indent=4)

def track_api_usage(api_key_hash,tier):
    now=int(time.time())
    entry=API_KEY_STORE.setdefault(api_key_hash,{"count":0,"window":now,"minute_calls":0})
    if now-entry["window"]>60: entry["window"]=now; entry["minute_calls"]=0
    entry["count"]+=1; entry["minute_calls"]+=1
    limits=API_KEYS[tier]
    if entry["count"]>limits["limit"] or entry["minute_calls"]>limits["rate_per_min"]: raise Exception("API quota exceeded")

def mint_nft(hash_value,network,owner):
    tx_hash=w3.keccak(text=hash_value+network+owner+timestamp()).hex()[:16]
    log_parallel("NFT_MINTED",{"hash":hash_value,"network":network,"owner":owner,"tx_hash":tx_hash})
    print(f"[NFT] Minted {hash_value[:8]}... on {network} for {owner} | TX_ID: {tx_hash}")
    return tx_hash

def publish_to_chain(hash_value,owner_address):
    tx_hash=w3.keccak(text=hash_value+owner_address+timestamp()).hex()[:16]
    log_parallel("BLOCKCHAIN_PUBLISH",{"hash":hash_value,"owner":owner_address,"tx_hash":tx_hash})
    print(f"[CHAIN] Published {hash_value[:8]}... | TX: {tx_hash}")
    return tx_hash

# -----------------------------
# JBits Node
# -----------------------------
class JBitsNode:
    def __init__(self,name,linked_hashes,network,protocol,platform,layer,variables,status="Active",conditional=False,monetization=False,nft=False):
        self.name=name; self.linked_hashes=linked_hashes; self.network=network; self.protocol=protocol
        self.platform=platform; self.layer=layer; self.variables=variables; self.status=status
        self.conditional=conditional; self.monetization=monetization; self.nft=nft
        self.claimed_by=None; self.claimed_amount=None
        self.hash=self.generate_hash(); self.tx_id=None
        if self.nft and NFT_ENABLED: self.tx_id=mint_nft(self.hash,self.network,random.choice(CLIENTS))
        log_parallel("NODE_CREATED",self.to_dict())

    def generate_hash(self):
        payload=json.dumps({"name":self.name,"linked_hashes":self.linked_hashes,"network":self.network,"protocol":self.protocol,"platform":self.platform,"layer":self.layer,"variables":self.variables,"conditional":self.conditional,"monetization":self.monetization,"nft":self.nft,"timestamp":timestamp()},sort_keys=True)
        return compute_hash(payload)
    
    def to_dict(self):
        return {"name":self.name,"hash":self.hash,"linked_hashes":self.linked_hashes,"network":self.network,"protocol":self.protocol,"platform":self.platform,"layer":self.layer,"variables":self.variables,"status":self.status,"conditional":self.conditional,"monetization":self.monetization,"nft":self.nft,"tx_id":self.tx_id,"claimed_by":self.claimed_by,"claimed_amount":self.claimed_amount}

# -----------------------------
# JBits Agent
# -----------------------------
class JBitsAgent:
    def __init__(self):
        self.nodes=[]; self.super_composite=""; self.layer_hashes=[]
    def add_layer_hash(self,name,data):
        h=compute_hash(data); self.layer_hashes.append({"name":name,"hash":h,"timestamp":timestamp()}); log_parallel("LAYER_HASH_ADDED",{"name":name,"hash":h}); return h
    def create_genesis(self):
        self.nodes.append(JBitsNode("H1",[],"Ethereum","EVM","Linux",1,{"core":"v1"},nft=True))
        self.nodes.append(JBitsNode("H1_inv",[],"Ethereum","EVM","Linux",1,{"core":"~v1"},nft=True))
        self.add_layer_hash("genesis_layer","".join([n.hash for n in self.nodes[:2]]))
    def create_branch(self,name,linked,network,protocol,platform,layer,variables,conditional=False,monetization=False,nft=False):
        b=JBitsNode(name,linked,network,protocol,platform,layer,variables,conditional,monetization,nft)
        self.nodes.append(b); log_parallel("BRANCH_CREATED",b.to_dict()); self.add_layer_hash(f"{name}_layer",b.hash)
        if b.monetization and b.nft: publish_to_chain(b.hash,random.choice(CLIENTS))
        return b.hash
    def fold_super_composite(self):
        self.super_composite=compute_hash("".join([n.hash for n in self.nodes]))
        log_parallel("SUPER_COMPOSITE_UPDATED",{"super_composite":self.super_composite}); self.add_layer_hash("super_composite_layer",self.super_composite)
        publish_to_chain(self.super_composite,WALLET_ADDRESS); return self.super_composite
    def parse_and_publish(self):
        for n in self.nodes:
            if n.monetization and n.nft: log_parallel("PUBLISH_EVENT",{"node":n.name,"hash":n.hash,"tx_id":n.tx_id})
        log_parallel("PUBLISH_SUPER_COMPOSITE",{"super_composite":self.super_composite})
    def simulate_payments(self):
        p=[]; 
        for n in self.nodes:
            if n.monetization:
                client=random.choice(CLIENTS); amount=round(random.uniform(0.1,1.0),3)
                pay={"node":n.name,"client":client,"amount":amount,"timestamp":timestamp()}; p.append(pay); log_parallel("PAYMENT_PROCESSED",pay)
        return p
    def export_ledger(self,filename="jbits_full_ledger.json"):
        data={"ledger":[n.to_dict() for n in self.nodes],"layer_hashes":self.layer_hashes,"super_composite":self.super_composite,"payments":self.simulate_payments(),"timestamp":timestamp()}
        with open(os.path.join(OUTPUT_DIR,filename),"w") as f: json.dump(data,f,indent=4)
        log_parallel("LEDGER_EXPORTED",{"filename":filename}); print(f"[+] Ledger exported: {os.path.join(OUTPUT_DIR,filename)}")
    def run_full_execution(self):
        self.create_genesis()
        self.create_branch("H2_branch",["H1","H1_inv"],"Solana","Custom","CloudVM",1,{"threshold":0.8},monetization=True,nft=True)
        self.create_branch("H2_neg_branch",["H1","H1_inv"],"PrivateChain","UTXO","Windows",1,{"threshold":0.3},monetization=True,nft=True)
        self.create_branch("H2_inverted_branch",["H1","H1_inv"],"OffChain","Custom","Linux",1,{"invert":True},monetization=True,nft=True)
        self.fold_super_composite(); self.parse_and_publish(); self.export_ledger()
        print("[*] Execution complete. Super-composite:",self.super_composite)

# -----------------------------
# Payment Watcher
# -----------------------------
def watch_payments():
    last_block=w3.eth.block_number
    while True:
        current_block=w3.eth.block_number
        for i in range(last_block+1,current_block+1):
            block=w3.eth.get_block(i,full_transactions=True)
            for tx in block.transactions:
                if tx.to and tx.to.lower()==WALLET_ADDRESS.lower() and tx.value>0:
                    amount_eth=w3.from_wei(tx.value,'ether'); payer=tx['from']
                    for n in agent.nodes:
                        if n.monetization and not n.claimed_by:
                            n.claimed_by=payer; n.claimed_amount=float(amount_eth)
                            log_parallel("PAYMENT_RECEIVED",{"node":n.name,"payer":payer,"amount":amount_eth,"tx_hash":tx.hash.hex()})
                            print(f"[PAYMENT] Node {n.name} claimed by {payer} for {amount_eth} ETH")
        last_block=current_block; time.sleep(15)

# -----------------------------
# Flask API
# -----------------------------
app=Flask(__name__); agent=JBitsAgent(); agent.run_full_execution()

@app.route("/ledger",methods=["GET"])
def get_ledger():
    ip=request.remote_addr or "0.0.0.0"; api_key=request.headers.get("X-API-KEY",OPENAI_KEY); tier=request.headers.get("X-API-TIER","free")
    track_api_usage(hash_api_key(api_key),tier); log_parallel("API_CALL",{"endpoint":"/ledger","api_key_fp":api_key_fingerprint(api_key),"hashed_ip":hash_ip(ip),"tier":tier,"timestamp":timestamp()})
    with open(os.path.join(OUTPUT_DIR,"jbits_full_ledger.json"),"r") as f: data=json.load(f)
    return jsonify(data)

@app.route("/run_branch",methods=["POST"])
def run_branch():
    data=request.json; name=data.get("name",f"branch_{len(agent.nodes)+1}"); linked=data.get("linked",[]); network=data.get("network","Ethereum"); protocol=data.get("protocol","EVM"); platform=data.get("platform","Linux"); layer=data.get("layer",1); variables=data.get("variables",{}); conditional=data.get("conditional",False); monetization=data.get("monetization",False); nft=data.get("nft",False)
    ip=request.remote_addr or "0.0.0.0"; api_key=request.headers.get("X-API-KEY",OPENAI_KEY); tier=request.headers.get("X-API-TIER","free")
    track_api_usage(hash_api_key(api_key),tier); log_parallel("API_CALL",{"endpoint":"/run_branch","api_key_fp":api_key_fingerprint(api_key),"hashed_ip":hash_ip(ip),"tier":tier,"timestamp":timestamp()})
    agent.create_branch(name,linked,network,protocol,platform,layer,variables,conditional,monetization,nft)
    agent.fold_super_composite(); agent.parse_and_publish(); agent.export_ledger()
    return jsonify({"status":"branch added","super_composite":agent.super_composite})

def run_api(): app.run(host="0.0.0.0",port=5000)

# -----------------------------
# START
# -----------------------------
if __name__=="__main__":
    threading.Thread(target=run_api).start()
    threading.Thread(target=watch_payments).start()